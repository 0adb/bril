#![allow(clippy::needless_lifetimes)]
#![allow(clippy::just_underscores_and_digits)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::new_without_default)]
#![allow(clippy::deprecated_cfg_attr)]
#![allow(clippy::single_char_pattern)]
#![allow(clippy::no_effect_underscore_binding)]
#![allow(clippy::unnested_or_patterns)]
#![allow(clippy::missing_errors_doc)]
#![allow(clippy::trivially_copy_pass_by_ref)]
#![allow(clippy::missing_const_for_fn)]
#![allow(clippy::unnecessary_wraps)]
#![allow(clippy::redundant_pub_crate)]
#![allow(clippy::cloned_instead_of_copied)]
#![allow(clippy::too_many_lines)]
#![allow(clippy::use_self)]
#![allow(clippy::needless_pass_by_value)]
#![allow(clippy::cast_sign_loss)]
#![allow(clippy::must_use_candidate)]
#![allow(clippy::cognitive_complexity)]
#![allow(clippy::ptr_arg)]
#![allow(clippy::uninlined_format_args)]

use std::str::FromStr;
use std::path::PathBuf;
use crate::Lines;
use bril_rs::{AbstractProgram, AbstractFunction, AbstractArgument, AbstractCode, AbstractInstruction, ConstOps, AbstractType, Literal, Import, ImportedFunction};

grammar(lines : &Lines);

match {
    r"\.(_|%|[A-Za-z])(_|%|\.|[A-Za-z]|[0-9])*" => LABEL_TOKEN, // label
    r"@(_|%|[A-Za-z])(_|%|\.|[A-Za-z]|[0-9])*" => FUNC_TOKEN, // func
    "const", "true", "false", "from", "import", "as"
} else {
    r"\s*" => { }, /// Whitespace
    r"#[^\n\r]*[\n\r]*" => { }, /// Comments
    r"(\+|-)?[0-9]+" => INT_TOKEN, // int
    r"(\+|-)?(((([0-9]+\.?[0-9]*)|(\.[0-9]+))(E|e)(\+|-)?[0-9]+)|(([0-9]+\.[0-9]*)|(\.[0-9]+)))" => FLOAT_TOKEN, // https://stackoverflow.com/questions/12643009/regular-expression-for-floating-point-numbers
    r"(_|%|[A-Za-z])(_|%|\.|[A-Za-z]|[0-9])*" => IDENT_TOKEN,
    r#""[^"]*""# => STRING_TOKEN,
    _
}

pub AbstractProgram : AbstractProgram = {
    <i: (<Imports>)*> <f :(<AbstractFunction>)*> => AbstractProgram {
        imports: i,
        functions : f,
    }
}

Imports : Import = {
    "from" <p: Path> "import" <n:(<ImportedFunction> ","?)*> ";" => {
        Import {
            path: p,
            functions: n,
        }
    }
}

ImportedFunction : ImportedFunction = {
    <n:Func> <a:Alias?> => {
        ImportedFunction {
            name: n,
            alias: a,
        }
    }
}

Alias : String = {
    "as" <a:Func> => {
        a
    }
}

AbstractFunction : AbstractFunction = {
    <loc:@L> <f: Func> <a: (Argument_List)?> <t:OutputType?> <loc2:@R> "{" <c :(<AbstractCode>)*> "}" => {let a = a.unwrap_or_default(); AbstractFunction {
        name : f,
        args : a,
        return_type : t,
        instrs: c,
        pos : lines.get_position(loc, loc2),
    }}
}

OutputType : AbstractType = {
    ":" <t:AbstractType> => t
}

Argument_List : Vec<AbstractArgument> = {
    "(" <a :(<AbstractArgument> ","?)*> ")" => a,
}

AbstractArgument : AbstractArgument = {
   <i:Ident> ":" <t: AbstractType> => AbstractArgument {
        name : i,
        arg_type : t,
    }
}

AbstractCode : AbstractCode = {
    <loc:@L> <l: Label> ":" <loc2:@R> => AbstractCode::Label{ label : l, pos : lines.get_position(loc, loc2)},
    <i: AbstractInstruction> => AbstractCode::Instruction(i),
}

AbstractInstruction : AbstractInstruction = {
    <loc:@L> <i:Ident> <t:(":" <AbstractType>)?> "=" <c: ConstOps> <l: Literal> ";" <loc2:@R> => AbstractInstruction::Constant {
        op : c,
        dest : i,
        const_type : t,
        value : l,
        pos : lines.get_position(loc, loc2),
    },
    <loc:@L> <i:Ident> <t:(":" <AbstractType>)?> "=" <v:Ident> <f :(<Args>)*> ";" <loc2:@R> => {
        let mut a_vec = Vec::new();
        let mut f_vec = Vec::new();
        let mut l_vec = Vec::new();
        for x in f {
            if x.starts_with("@") {
                f_vec.push(x.strip_prefix("@").unwrap().to_owned());
            } else if x.starts_with(".") {
                l_vec.push(x.strip_prefix(".").unwrap().to_owned());
            } else {a_vec.push(x);}
        }
        AbstractInstruction::Value {
            op: v,
            dest: i,
            op_type : t,
            args: a_vec,
            funcs: f_vec,
            labels: l_vec,
            pos : lines.get_position(loc, loc2),
        }
    },
    <loc:@L> <e:Ident> <f :(<Args>)*> ";" <loc2:@R> => {
        let mut a_vec = Vec::new();
        let mut f_vec = Vec::new();
        let mut l_vec = Vec::new();
        for x in f {
            if x.starts_with("@") {
                f_vec.push(x.strip_prefix("@").unwrap().to_owned());
            } else if x.starts_with(".") {
                l_vec.push(x.strip_prefix(".").unwrap().to_owned());
            } else {a_vec.push(x);}
        }
        AbstractInstruction::Effect {
            op: e,
            args: a_vec,
            funcs: f_vec,
            labels: l_vec,
            pos : lines.get_position(loc, loc2),
        }
    }

}

ConstOps : ConstOps = {
    "const" => ConstOps::Const,
}

AbstractType : AbstractType = {
    <t:Ident> => AbstractType::Primitive(t),
    <p:Ident> "<" <t:AbstractType> ">" => AbstractType::Parameterized(p, Box::new(t)),
}

// We can't match on const because of a reduce-reduce conflict
Ident: String = {
    <s : IDENT_TOKEN> => s.to_string(),
    "true" => "true".to_owned(),
    "false" => "false".to_owned(),
}

Args: String = {
    <f:Func> => format!("@{}", f),
    <l:Label> => format!(".{}", l),
    <i:Ident> => i,
}

pub Func : String = {
    <i:FUNC_TOKEN> => i.strip_prefix("@").unwrap().to_owned(),
}

Path: PathBuf = {
    <p:STRING_TOKEN> => {
        PathBuf::from(p.trim_matches('\"'))
    }
}

Label: String = {
    <i:LABEL_TOKEN> => i.strip_prefix(".").unwrap().to_owned(),
}

Literal: Literal = {
    <n: Num> => Literal::Int(n),
    <b: Bool> => Literal::Bool(b),
    <f: Float> => Literal::Float(f),
}

Num: i64 = <s:INT_TOKEN> => i64::from_str(s).unwrap();
Bool: bool = {
    "true" => true,
    "false" => false,
}

Float: f64 = <f:FLOAT_TOKEN> => f64::from_str(f).unwrap();
